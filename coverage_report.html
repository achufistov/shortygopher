
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/achufistov/shortygopher.git/internal/app/config/config.go (80.0%)</option>
				
				<option value="file1">github.com/achufistov/shortygopher.git/internal/app/handlers/handlers.go (65.7%)</option>
				
				<option value="file2">github.com/achufistov/shortygopher.git/internal/app/middleware/auth_middleware.go (87.0%)</option>
				
				<option value="file3">github.com/achufistov/shortygopher.git/internal/app/middleware/gzip_middleware.go (0.0%)</option>
				
				<option value="file4">github.com/achufistov/shortygopher.git/internal/app/middleware/log_middleware.go (0.0%)</option>
				
				<option value="file5">github.com/achufistov/shortygopher.git/internal/app/storage/database.go (0.0%)</option>
				
				<option value="file6">github.com/achufistov/shortygopher.git/internal/app/storage/osfile.go (83.3%)</option>
				
				<option value="file7">github.com/achufistov/shortygopher.git/internal/app/storage/urlstorage.go (98.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package config provides functions for loading and managing application configuration.
package config

import (
        "flag"
        "fmt"
        "os"
        "strings"
)

var (
        addressFlag     = flag.String("a", "localhost:8080", "HTTP server address")
        baseURLFlag     = flag.String("b", "http://localhost:8080", "Base URL for shortened links")
        fileStoragePath = flag.String("f", "urls.json", "File for storing urls")
        databaseDSNFlag = flag.String("d", "", "Database connection string")
        jwtSecretFile   = flag.String("jwt-secret-file", "secret.key", "Path to JWT secret file")
        flagsDefined    = false
)

// Config contains all configuration parameters for the URL shortening service.
// Configuration can be set via environment variables or command line flags.
//
// Setting priority (from highest to lowest):
//  1. Environment variables
//  2. Command line flags
//  3. Default values
//
// Example usage:
//
//        cfg, err := config.LoadConfig()
//        if err != nil {
//                log.Fatal(err)
//        }
//        fmt.Printf("Server started on %s\n", cfg.Address)
type Config struct {
        // Address defines the address and port for the HTTP server (e.g., "localhost:8080")
        Address string

        // BaseURL defines the base URL for generating shortened links
        BaseURL string

        // FileStorage defines the path to the file for persistent URL storage (can be empty)
        FileStorage string

        // DatabaseDSN contains the database connection string (can be empty)
        DatabaseDSN string

        // SecretKey contains the secret key for JWT token signing
        SecretKey string
}

// LoadConfig loads configuration from environment variables and command line flags.
// Returns a pointer to Config struct or an error if configuration loading fails.
//
// Supported environment variables:
//   - SERVER_ADDRESS: server address
//   - BASE_URL: base URL
//   - FILE_STORAGE_PATH: storage file path
//   - DATABASE_DSN: database connection string
//   - JWT_SECRET_FILE: path to JWT secret file
//
// Supported flags:
//   - -a: server address
//   - -b: base URL
//   - -f: storage file path
//   - -d: database connection string
//   - -jwt-secret-file: path to JWT secret file
func LoadConfig() (*Config, error) <span class="cov8" title="1">{
        if !flagsDefined </span><span class="cov8" title="1">{
                flag.Parse()
                flagsDefined = true
        }</span>

        <span class="cov8" title="1">address := os.Getenv("SERVER_ADDRESS")
        baseURL := os.Getenv("BASE_URL")
        fileStorage := os.Getenv("FILE_STORAGE_PATH")
        databaseDSN := os.Getenv("DATABASE_DSN")

        if address == "" </span><span class="cov0" title="0">{
                address = *addressFlag
        }</span>
        <span class="cov8" title="1">if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = *baseURLFlag
        }</span>
        <span class="cov8" title="1">if fileStorage == "" </span><span class="cov0" title="0">{
                fileStorage = *fileStoragePath
        }</span>
        <span class="cov8" title="1">if databaseDSN == "" </span><span class="cov8" title="1">{
                databaseDSN = *databaseDSNFlag
        }</span>

        <span class="cov8" title="1">secretFile := os.Getenv("JWT_SECRET_FILE")
        if secretFile == "" </span><span class="cov0" title="0">{
                secretFile = *jwtSecretFile
        }</span>

        <span class="cov8" title="1">secretKeyBytes, err := os.ReadFile(secretFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read JWT secret file: %v", err)
        }</span>
        <span class="cov8" title="1">secretKey := strings.TrimSpace(string(secretKeyBytes))

        if address == "" || baseURL == "" || fileStorage == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("address, base URL, file storage path must be provided")
        }</span>

        <span class="cov8" title="1">return &amp;Config{
                Address:     address,
                BaseURL:     baseURL,
                FileStorage: fileStorage,
                DatabaseDSN: databaseDSN,
                SecretKey:   secretKey,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package handlers provides HTTP handlers for the URL shortening service.
package handlers

import (
        "crypto/rand"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "strings"

        "github.com/achufistov/shortygopher.git/internal/app/config"
        "github.com/achufistov/shortygopher.git/internal/app/middleware"
        "github.com/achufistov/shortygopher.git/internal/app/storage"
        "github.com/go-chi/chi/v5"
)

var storageInstance storage.Storage

// ShortenRequest represents a URL shortening request in JSON format.
// Used in the POST /api/shorten endpoint.
//
// Example JSON:
//
//        {
//          "url": "https://example.com/very/long/path"
//        }
type ShortenRequest struct {
        OriginalURL string `json:"url"`
}

// ShortenResponse represents a URL shortening response in JSON format.
// Returned from the POST /api/shorten endpoint.
//
// Example JSON:
//
//        {
//          "result": "http://localhost:8080/abc123"
//        }
type ShortenResponse struct {
        ShortURL string `json:"result"`
}

// BatchRequest represents one item in a batch request for shortening multiple URLs.
// Used in the POST /api/shorten/batch endpoint.
type BatchRequest struct {
        CorrelationID string `json:"correlation_id"`
        OriginalURL   string `json:"original_url"`
}

// BatchResponse represents one item in a batch response for shortening multiple URLs.
// Returned from the POST /api/shorten/batch endpoint.
type BatchResponse struct {
        CorrelationID string `json:"correlation_id"`
        ShortURL      string `json:"short_url"`
}

// InitStorage initializes the global storage instance.
// Must be called before using any handlers.
//
// Example:
//
//        storage := storage.NewURLStorage()
//        handlers.InitStorage(storage)
func InitStorage(storage storage.Storage) <span class="cov8" title="1">{
        storageInstance = storage
}</span>

// HandlePost handles POST / requests for URL shortening in text format.
// Accepts the original URL in the request body as text/plain.
// Returns the shortened URL in the response body.
//
// HTTP methods: POST
// Content-Type: text/plain
// Response: text/plain with shortened URL
//
// Response codes:
//   - 201: URL successfully shortened
//   - 400: Invalid request method or Content-Type
//   - 401: User not authorized
//   - 409: URL already exists
//   - 500: Internal server error
func HandlePost(cfg *config.Config, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Invalid request method", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var originalURL string

        contentType := r.Header.Get("Content-Type")
        if !strings.Contains(contentType, "application/json") &amp;&amp; !strings.Contains(contentType, "text/plain") </span><span class="cov0" title="0">{
                http.Error(w, "Invalid content type", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if strings.Contains(contentType, "application/json") </span><span class="cov8" title="1">{
                var req ShortenRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid request body", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">originalURL = req.OriginalURL</span>
        } else<span class="cov8" title="1"> {
                body, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid request body", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">originalURL = string(body)</span>
        }

        <span class="cov8" title="1">userID, ok := r.Context().Value(middleware.UserIDKey).(string)
        if !ok </span><span class="cov8" title="1">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">shortURL := generateShortURL()
        err := storageInstance.AddURL(shortURL, originalURL, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "URL already exists" </span><span class="cov0" title="0">{
                        existingShortURL, exists := storageInstance.GetShortURLByOriginalURL(originalURL)
                        if !exists </span><span class="cov0" title="0">{
                                http.Error(w, "Failed to get existing short URL", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/plain")
                        w.WriteHeader(http.StatusConflict)
                        fmt.Fprintf(w, "%s/%s", cfg.BaseURL, existingShortURL)
                        return</span>
                }
                <span class="cov0" title="0">http.Error(w, "Failed to save URL mapping", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">if cfg.FileStorage != "" </span><span class="cov8" title="1">{
                if err := storage.SaveSingleURLMapping(cfg.FileStorage, shortURL, originalURL); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to save URL mapping to file: %v", err)
                }</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(http.StatusCreated)
        fmt.Fprintf(w, "%s/%s", cfg.BaseURL, shortURL)</span>
}

// HandleShortenPost handles POST /api/shorten requests for URL shortening in JSON format.
// Accepts JSON with original URL and returns JSON with shortened URL.
//
// HTTP methods: POST
// Content-Type: application/json
// Response: application/json with ShortenResponse object
//
// Response codes:
//   - 201: URL successfully shortened
//   - 400: Invalid request method or JSON
//   - 401: User not authorized
//   - 409: URL already exists
//   - 500: Internal server error
func HandleShortenPost(cfg *config.Config, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Invalid request method", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var req ShortenRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">userID, ok := r.Context().Value(middleware.UserIDKey).(string)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov8" title="1">shortURL := generateShortURL()
        err := storageInstance.AddURL(shortURL, req.OriginalURL, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "URL already exists" </span><span class="cov0" title="0">{
                        existingShortURL, exists := storageInstance.GetShortURLByOriginalURL(req.OriginalURL)
                        if !exists </span><span class="cov0" title="0">{
                                http.Error(w, "Failed to get existing short URL", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">resp := ShortenResponse{
                                ShortURL: fmt.Sprintf("%s/%s", cfg.BaseURL, existingShortURL),
                        }
                        w.Header().Set("Content-Type", "application/json")
                        w.WriteHeader(http.StatusConflict)
                        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">http.Error(w, "Failed to save URL mapping", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">if cfg.FileStorage != "" </span><span class="cov8" title="1">{
                if err := storage.SaveSingleURLMapping(cfg.FileStorage, shortURL, req.OriginalURL); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to save URL mapping to file: %v", err)
                }</span>
        }

        <span class="cov8" title="1">resp := ShortenResponse{
                ShortURL: fmt.Sprintf("%s/%s", cfg.BaseURL, shortURL),
        }
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// HandleGet handles GET /{id} requests for redirecting to the original URL.
// Looks up the original URL by short identifier and performs HTTP redirect.
//
// HTTP methods: GET
// URL parameters: id - short URL identifier
// Response: HTTP redirect (307 Temporary Redirect)
//
// Response codes:
//   - 307: Successful redirect to original URL
//   - 400: Invalid request method
//   - 404: URL not found
//   - 410: URL was deleted
func HandleGet(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request method", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">id := chi.URLParam(r, "id")
        originalURL, exists, isDeleted := storageInstance.GetURL(id)

        if !exists </span><span class="cov8" title="1">{
                http.Error(w, "URL not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">if isDeleted </span><span class="cov8" title="1">{
                http.Error(w, "URL has been deleted", http.StatusGone)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Location", originalURL)
        w.WriteHeader(http.StatusTemporaryRedirect)</span>
}

// HandlePing returns a handler for checking storage availability.
// The endpoint is used for health checks and monitoring.
//
// HTTP methods: GET
// URL: /ping
// Response: HTTP status without body
//
// Response codes:
//   - 200: Storage is available
//   - 400: Invalid request method
//   - 500: Storage is unavailable
func HandlePing(storageInstance storage.Storage) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid request method", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">if err := storageInstance.Ping(); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to ping storage", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
        }
}

// HandleBatchShortenPost handles POST /api/shorten/batch requests for shortening multiple URLs at once.
// Accepts an array of BatchRequest and returns an array of BatchResponse with shortened URLs.
//
// HTTP methods: POST
// Content-Type: application/json
// Response: application/json with array of BatchResponse
//
// Example request:
//
//        [
//          {"correlation_id": "1", "original_url": "https://example.com"},
//          {"correlation_id": "2", "original_url": "https://google.com"}
//        ]
//
// Response codes:
//   - 201: URLs successfully shortened
//   - 400: Invalid request method, JSON, or empty array
//   - 401: User not authorized
//   - 500: Internal server error
func HandleBatchShortenPost(cfg *config.Config, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request method", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">userID, ok := r.Context().Value(middleware.UserIDKey).(string)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>
        <span class="cov8" title="1">var batchRequests []BatchRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;batchRequests); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if len(batchRequests) == 0 </span><span class="cov8" title="1">{
                http.Error(w, "Empty batch", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">batchResponses := make([]BatchResponse, 0, len(batchRequests))

        urlsToSave := make(map[string]string, len(batchRequests))

        for _, req := range batchRequests </span><span class="cov8" title="1">{
                shortURL := generateShortURL()
                err := storageInstance.AddURL(shortURL, req.OriginalURL, userID)
                if err != nil &amp;&amp; err.Error() != "URL already exists" </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to save URL mapping", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">batchResponses = append(batchResponses, BatchResponse{
                        CorrelationID: req.CorrelationID,
                        ShortURL:      fmt.Sprintf("%s/%s", cfg.BaseURL, shortURL),
                })
                urlsToSave[shortURL] = req.OriginalURL</span>
        }

        <span class="cov8" title="1">if cfg.FileStorage != "" &amp;&amp; len(urlsToSave) &gt; 0 </span><span class="cov8" title="1">{
                if err := storage.SaveURLMappings(cfg.FileStorage, urlsToSave); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to save URL mappings to file: %v", err)
                }</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(batchResponses); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                return
        }</span>
}

// HandleGetUserURLs returns a handler for getting all URLs created by the authenticated user.
// Requires user authentication via JWT token in cookies.
//
// HTTP methods: GET
// Content-Type: application/json
// Response: JSON array of user's URLs with short_url and original_url fields
//
// Response codes:
//   - 200: URLs successfully retrieved
//   - 204: User has no URLs
//   - 401: User not authenticated
//   - 500: Internal server error
func HandleGetUserURLs(cfg *config.Config) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                userID, ok := r.Context().Value(middleware.UserIDKey).(string)
                if !ok || userID == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov8" title="1">urls, err := storageInstance.GetURLsByUser(userID)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal server error", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">if len(urls) == 0 </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>
                <span class="cov8" title="1">response := make([]struct {
                        ShortURL    string `json:"short_url"`
                        OriginalURL string `json:"original_url"`
                }, 0)
                for short, original := range urls </span><span class="cov8" title="1">{
                        response = append(response, struct {
                                ShortURL    string `json:"short_url"`
                                OriginalURL string `json:"original_url"`
                        }{
                                ShortURL:    fmt.Sprintf("%s/%s", cfg.BaseURL, short),
                                OriginalURL: original,
                        })
                }</span>
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to encode response", http.StatusInternalServerError)
                }</span>
        }
}

// HandleDeleteUserURLs returns a handler for asynchronously deleting specified URLs.
// Accepts a JSON array of short URL IDs and marks them for deletion.
//
// HTTP methods: DELETE
// Content-Type: application/json
// Request body: JSON array of short URL strings
//
// Response codes:
//   - 202: Deletion request accepted (async operation)
//   - 400: Invalid request method or JSON body
func HandleDeleteUserURLs(cfg *config.Config) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if r.Method != http.MethodDelete </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid request method", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">var shortURLs []string
                if err := json.NewDecoder(r.Body).Decode(&amp;shortURLs); err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid request body", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">deleteChan := make(chan error)

                go func() </span><span class="cov0" title="0">{
                        err := storageInstance.DeleteURLs(shortURLs, "")
                        deleteChan &lt;- err
                }</span>()

                <span class="cov8" title="1">w.WriteHeader(http.StatusAccepted)

                go func() </span><span class="cov0" title="0">{
                        err := &lt;-deleteChan
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to delete URLs: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Println("URLs deleted successfully")
                        }</span>
                }()
        }
}

func generateShortURL() string <span class="cov8" title="1">{
        b := make([]byte, 6)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">return base64.URLEncoding.EncodeToString(b)[:6]</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/achufistov/shortygopher.git/internal/app/config"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type contextKey string

// UserIDKey is the context key used to store and retrieve user ID from request context.
// Used by authentication middleware to pass user information between handlers.
const UserIDKey contextKey = "userID"

// AuthMiddleware returns HTTP middleware that handles JWT-based authentication.
// Validates existing JWT tokens from cookies or creates new ones for unauthenticated users.
// Sets user ID in request context for downstream handlers to access.
//
// The middleware:
//   - Checks for existing auth_token cookie
//   - Validates JWT token if present
//   - Generates new JWT token and sets cookie for new users
//   - Adds user ID to request context using UserIDKey
func AuthMiddleware(cfg *config.Config) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        var userID string
                        cookie, err := r.Cookie("auth_token")

                        if err == nil </span><span class="cov8" title="1">{
                                token, err := jwt.Parse(cookie.Value, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                                        }</span>
                                        <span class="cov8" title="1">return []byte(cfg.SecretKey), nil</span>
                                })

                                <span class="cov8" title="1">if err == nil &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                                        if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov8" title="1">{
                                                if uid, ok := claims["user_id"].(string); ok </span><span class="cov8" title="1">{
                                                        userID = uid
                                                }</span>
                                        }
                                }
                        }

                        <span class="cov8" title="1">if userID == "" </span><span class="cov8" title="1">{
                                userID = uuid.NewString()
                                token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                                        "user_id": userID,
                                        "exp":     time.Now().Add(24 * time.Hour).Unix(),
                                })

                                tokenString, err := token.SignedString([]byte(cfg.SecretKey))
                                if err != nil </span><span class="cov0" title="0">{
                                        http.Error(w, "Failed to generate token", http.StatusInternalServerError)
                                        return
                                }</span>

                                <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                                        Name:     "auth_token",
                                        Value:    tokenString,
                                        Path:     "/",
                                        HttpOnly: true,
                                        MaxAge:   86400,
                                })</span>
                        }

                        <span class="cov8" title="1">ctx := context.WithValue(r.Context(), UserIDKey, userID)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "compress/gzip"
        "io"
        "net/http"
        "strings"
        "sync"
)

var gzipWriterPool = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{
                w, _ := gzip.NewWriterLevel(io.Discard, gzip.DefaultCompression)
                return w
        }</span>,
}

// gzipResponseWriter wraps http.ResponseWriter to provide gzip compression functionality.
// Implements transparent compression for supported content types.
type gzipResponseWriter struct {
        http.ResponseWriter
        gzWriter   *gzip.Writer
        shouldGzip bool
}

// WriteHeader writes the HTTP status code and sets up gzip compression if needed.
// Configures compression headers and initializes gzip writer from pool.
func (w *gzipResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        contentType := w.Header().Get("Content-Type")
        if w.shouldGzip &amp;&amp; shouldCompress(contentType) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Encoding", "gzip")
                w.Header().Add("Vary", "Accept-Encoding")

                w.gzWriter = gzipWriterPool.Get().(*gzip.Writer)
                w.gzWriter.Reset(w.ResponseWriter)
        }</span>
        <span class="cov0" title="0">w.ResponseWriter.WriteHeader(statusCode)</span>
}

// Write writes data to the response, compressing if gzip is enabled.
// Routes data through gzip writer if compression is active.
func (w *gzipResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if w.gzWriter != nil </span><span class="cov0" title="0">{
                return w.gzWriter.Write(b)
        }</span>
        <span class="cov0" title="0">return w.ResponseWriter.Write(b)</span>
}

// Close closes the gzip writer and returns it to the pool for reuse.
// Must be called to properly clean up resources and avoid memory leaks.
func (w *gzipResponseWriter) Close() <span class="cov0" title="0">{
        if w.gzWriter != nil </span><span class="cov0" title="0">{
                w.gzWriter.Close()

                w.gzWriter.Reset(io.Discard)
                gzipWriterPool.Put(w.gzWriter)
                w.gzWriter = nil
        }</span>
}

// shouldCompress determines if the given content type should be compressed.
// Returns true for text and JSON content types that benefit from compression.
func shouldCompress(contentType string) bool <span class="cov0" title="0">{
        compressibleTypes := []string{
                "text/plain",
                "text/html",
                "application/json",
                "application/javascript",
                "text/css",
                "application/xml",
        }

        for _, t := range compressibleTypes </span><span class="cov0" title="0">{
                if strings.HasPrefix(contentType, t) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GzipMiddleware returns HTTP middleware that handles gzip compression for both requests and responses.
// Automatically decompresses incoming gzip requests and compresses outgoing responses when supported.
//
// Features:
//   - Decompresses incoming requests with Content-Encoding: gzip
//   - Compresses responses for clients that Accept-Encoding: gzip
//   - Uses sync.Pool for efficient gzip writer reuse
//   - Supports text/plain, application/json, and other compressible content types
//   - Handles application/x-gzip content type conversion
func GzipMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // process incoming gzip
                if strings.Contains(r.Header.Get("Content-Encoding"), "gzip") </span><span class="cov0" title="0">{
                        gzReader, err := gzip.NewReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Invalid gzip body", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov0" title="0">defer gzReader.Close()
                        r.Body = gzReader</span>
                }

                <span class="cov0" title="0">if r.Header.Get("Content-Type") == "application/x-gzip" </span><span class="cov0" title="0">{
                        r.Header.Set("Content-Type", "text/plain")
                }</span>

                <span class="cov0" title="0">acceptsGzip := strings.Contains(r.Header.Get("Accept-Encoding"), "gzip")

                gzw := &amp;gzipResponseWriter{
                        ResponseWriter: w,
                        shouldGzip:     acceptsGzip,
                }
                defer gzw.Close()

                next.ServeHTTP(gzw, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "net/http"
        "time"

        "go.uber.org/zap"
)

// LoggingMiddleware returns HTTP middleware that logs request and response information.
// Uses structured logging with zap to record HTTP method, URI, status, size, and duration.
//
// Logs two entries per request:
//   - Request: method and URI when request starts
//   - Response: status code, response size, and total duration
func LoggingMiddleware(logger *zap.Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()

                        logger.Info("Request",
                                zap.String("method", r.Method),
                                zap.String("uri", r.RequestURI),
                        )

                        rw := &amp;responseWriter{ResponseWriter: w}
                        next.ServeHTTP(rw, r)

                        logger.Info("Response",
                                zap.Int("status", rw.status),
                                zap.Int("size", rw.size),
                                zap.Duration("duration", time.Since(start)),
                        )
                }</span>)
        }
}

// responseWriter wraps http.ResponseWriter to capture response status and size.
// Used by logging middleware to record response metadata.
type responseWriter struct {
        http.ResponseWriter
        status int
        size   int
}

// WriteHeader captures the HTTP status code for logging.
func (rw *responseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        rw.status = statusCode
        rw.ResponseWriter.WriteHeader(statusCode)
}</span>

// Write captures the response size and forwards data to the underlying writer.
func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        size, err := rw.ResponseWriter.Write(b)
        rw.size += size
        return size, err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package storage

import (
        "database/sql"
        "fmt"

        "github.com/lib/pq"
)

// DBStorage implements the Storage interface using PostgreSQL database.
// Provides persistent storage for URL mappings with support for user associations and soft deletes.
type DBStorage struct {
        db *sql.DB
}

// NewDBStorage creates a new DBStorage instance connected to PostgreSQL.
// Establishes database connection, verifies connectivity, and creates required tables.
// Returns error if connection fails or table creation fails.
func NewDBStorage(dsn string) (*DBStorage, error) <span class="cov0" title="0">{
        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to establish connection for the database : %v", err)
        }</span>
        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %v", err)
        }</span>

        <span class="cov0" title="0">createTableQuery := `
        CREATE TABLE IF NOT EXISTS urls (
                id SERIAL PRIMARY KEY,
                url TEXT NOT NULL UNIQUE,
                short_url TEXT NOT NULL UNIQUE,
                user_id TEXT NOT NULL,
                is_deleted BOOLEAN DEFAULT FALSE
        );
        `
        if _, err = db.Exec(createTableQuery); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to create database: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;DBStorage{db: db}, nil</span>
}

// AddURL adds a new URL mapping to the database.
// Uses ON CONFLICT to handle duplicate URLs gracefully.
// Returns error if URL already exists or database operation fails.
func (s *DBStorage) AddURL(shortURL, originalURL, userID string) error <span class="cov0" title="0">{
        query := `
    INSERT INTO urls (url, short_url, user_id)
    VALUES ($1, $2, $3)
    ON CONFLICT (url) DO NOTHING
    RETURNING short_url;
    `
        var existingShortURL string
        err := s.db.QueryRow(query, originalURL, shortURL, userID).Scan(&amp;existingShortURL)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("URL already exists")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to add URL to database: %v", err)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// AddURLs adds multiple URL mappings in a single database transaction.
// Rolls back all changes if any URL fails to insert.
// More efficient than multiple individual AddURL calls.
func (s *DBStorage) AddURLs(urls map[string]string, userID string) error <span class="cov0" title="0">{
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %v", err)
        }</span>

        <span class="cov0" title="0">query := `INSERT INTO urls (url, short_url, user_id) VALUES ($1, $2, $3)`
        for shortURL, originalURL := range urls </span><span class="cov0" title="0">{
                _, err := tx.Exec(query, originalURL, shortURL, userID)
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("failed to add URL to database: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetURL retrieves the original URL and deletion status for a short URL.
// Returns original URL, existence flag, and deletion status.
func (s *DBStorage) GetURL(shortURL string) (string, bool, bool) <span class="cov0" title="0">{
        var originalURL string
        var isDeleted bool
        query := `SELECT url, is_deleted FROM urls WHERE short_url = $1`
        err := s.db.QueryRow(query, shortURL).Scan(&amp;originalURL, &amp;isDeleted)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, false
        }</span>
        <span class="cov0" title="0">return originalURL, true, isDeleted</span>
}

// GetAllURLs retrieves all URL mappings from the database.
// Returns a map of short URL to original URL for all stored mappings.
func (s *DBStorage) GetAllURLs() map[string]string <span class="cov0" title="0">{
        urlMap := make(map[string]string)
        query := `SELECT short_url, url FROM urls`
        rows, err := s.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get URLs from database: %v\n", err)
                return urlMap
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var shortURL, originalURL string
                if err := rows.Scan(&amp;shortURL, &amp;originalURL); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to scan row: %v\n", err)
                        continue</span>
                }
                <span class="cov0" title="0">urlMap[shortURL] = originalURL</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to iterate over rows: %v\n", err)
        }</span>
        <span class="cov0" title="0">return urlMap</span>
}

// GetShortURLByOriginalURL finds the short URL for a given original URL.
// Returns short URL and found flag. Useful for checking existing mappings.
func (s *DBStorage) GetShortURLByOriginalURL(originalURL string) (string, bool) <span class="cov0" title="0">{
        var shortURL string
        query := `SELECT short_url FROM urls WHERE url = $1`
        err := s.db.QueryRow(query, originalURL).Scan(&amp;shortURL)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov0" title="0">fmt.Printf("Failed to get short URL by original URL: %v", err)
                return "", false</span>
        }
        <span class="cov0" title="0">return shortURL, true</span>
}

// GetURLsByUser retrieves all URL mappings created by a specific user.
// Returns a map of short URL to original URL for the specified user.
func (s *DBStorage) GetURLsByUser(userID string) (map[string]string, error) <span class="cov0" title="0">{
        urlMap := make(map[string]string)
        query := `SELECT short_url, url FROM urls WHERE user_id = $1`
        rows, err := s.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query URLs by user: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var shortURL, originalURL string
                if err := rows.Scan(&amp;shortURL, &amp;originalURL); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %v", err)
                }</span>
                <span class="cov0" title="0">urlMap[shortURL] = originalURL</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows error: %v", err)
        }</span>

        <span class="cov0" title="0">return urlMap, nil</span>
}

// DeleteURLs soft-deletes URLs by setting is_deleted flag to true.
// Uses PostgreSQL array operations for efficient batch deletion.
func (s *DBStorage) DeleteURLs(shortURLs []string, userID string) error <span class="cov0" title="0">{
        query := `UPDATE urls SET is_deleted = TRUE WHERE short_url = ANY($1)`
        _, err := s.db.Exec(query, pq.Array(shortURLs))
        return err
}</span>

// Ping checks database connectivity.
// Returns error if database is unreachable.
func (s *DBStorage) Ping() error <span class="cov0" title="0">{
        return s.db.Ping()
}</span>

// Close closes the database connection.
// Should be called when storage is no longer needed.
func (s *DBStorage) Close() error <span class="cov0" title="0">{
        return s.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package storage

import (
        "bufio"
        "encoding/json"
        "os"
        "sync"
        "time"

        "github.com/google/uuid"
)

// URLMapping represents a single URL mapping entry for JSON serialization.
// Used for storing URL data in JSON Lines format.
type URLMapping struct {
        UUID        string `json:"uuid"`
        ShortURL    string `json:"short_url"`
        OriginalURL string `json:"original_url"`
        UserID      string `json:"user_id"`
}

// BatchFileSaver provides efficient batch saving of URL mappings to file.
// Accumulates URLs in memory and periodically saves them to reduce I/O operations.
type BatchFileSaver struct {
        mu           sync.Mutex
        pendingURLs  map[string]string
        filePath     string
        saveInterval time.Duration
}

var (
        globalSaver     *BatchFileSaver
        globalSaverOnce sync.Once
)

// GetBatchSaver returns a singleton BatchFileSaver instance for the given file path.
// Ensures only one saver exists per file to avoid conflicts.
func GetBatchSaver(filePath string) *BatchFileSaver <span class="cov8" title="1">{
        globalSaverOnce.Do(func() </span><span class="cov8" title="1">{
                globalSaver = &amp;BatchFileSaver{
                        pendingURLs:  make(map[string]string),
                        filePath:     filePath,
                        saveInterval: 5 * time.Second,
                }
                go globalSaver.periodicSave()
        }</span>)
        <span class="cov8" title="1">return globalSaver</span>
}

// AddURL adds a URL mapping to the pending save queue.
// Thread-safe operation that queues URL for next batch save.
func (b *BatchFileSaver) AddURL(shortURL, originalURL string) <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.pendingURLs[shortURL] = originalURL
}</span>

// periodicSave runs in a goroutine to save pending URLs at regular intervals.
func (b *BatchFileSaver) periodicSave() <span class="cov8" title="1">{
        ticker := time.NewTicker(b.saveInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                b.forceSave()
        }</span>
}

func (b *BatchFileSaver) forceSave() error <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        if len(b.pendingURLs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return b.saveToFile()</span>
}

func (b *BatchFileSaver) saveToFile() error <span class="cov8" title="1">{
        tmpFile := b.filePath + ".tmp"
        file, err := os.Create(tmpFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        writer := bufio.NewWriter(file)
        defer writer.Flush()

        for shortURL, originalURL := range b.pendingURLs </span><span class="cov8" title="1">{
                mapping := URLMapping{
                        UUID:        generateUUID(),
                        ShortURL:    shortURL,
                        OriginalURL: originalURL,
                        UserID:      "system",
                }
                line, err := json.Marshal(mapping)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">writer.Write(line)
                writer.WriteString("\n")</span>
        }

        <span class="cov8" title="1">b.pendingURLs = make(map[string]string)

        return os.Rename(tmpFile, b.filePath)</span>
}

// LoadURLMappings loads URL mappings from a JSON Lines file.
// Returns empty map if file doesn't exist. Skips invalid JSON entries.
func LoadURLMappings(filePath string) (map[string]string, error) <span class="cov8" title="1">{
        urlMap := make(map[string]string)
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return urlMap, nil
        }</span>

        <span class="cov8" title="1">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                var mapping URLMapping
                if err := json.Unmarshal(scanner.Bytes(), &amp;mapping); err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">urlMap[mapping.ShortURL] = mapping.OriginalURL</span>
        }

        <span class="cov8" title="1">return urlMap, scanner.Err()</span>
}

// SaveURLMappings saves a map of URL mappings to file using batch saver.
// More efficient than saving individual URLs.
func SaveURLMappings(filePath string, urlMap map[string]string) error <span class="cov0" title="0">{
        saver := GetBatchSaver(filePath)

        for shortURL, originalURL := range urlMap </span><span class="cov0" title="0">{
                saver.AddURL(shortURL, originalURL)
        }</span>

        <span class="cov0" title="0">return saver.forceSave()</span>
}

// SaveSingleURLMapping saves a single URL mapping to file using batch saver.
// Convenience function for saving individual URLs.
func SaveSingleURLMapping(filePath string, shortURL, originalURL string) error <span class="cov8" title="1">{
        saver := GetBatchSaver(filePath)
        saver.AddURL(shortURL, originalURL)
        return saver.forceSave()
}</span>

func generateUUID() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package storage

import (
        "sync"
)

// URLInfo contains information about a stored URL, including the deletion flag.
type URLInfo struct {
        OriginalURL string
        UserID      string
        IsDeleted   bool
}

// URLStorage represents an in-memory storage for URL mappings.
// Implements the Storage interface and supports concurrent access via sync.RWMutex.
//
// Example usage:
//
//        storage := NewURLStorage()
//        err := storage.AddURL("abc123", "https://example.com", "user1")
//        if err != nil {
//                log.Fatal(err)
//        }
type URLStorage struct {
        mu      sync.RWMutex
        URLs    map[string]URLInfo
        mapPool sync.Pool
}

// NewURLStorage creates a new URLStorage instance with an initialized URL map.
// Returns a ready-to-use storage object.
func NewURLStorage() *URLStorage <span class="cov8" title="1">{
        storage := &amp;URLStorage{
                URLs: make(map[string]URLInfo, 1000),
        }

        storage.mapPool = sync.Pool{
                New: func() interface{} </span><span class="cov8" title="1">{
                        return make(map[string]string, 100)
                }</span>,
        }

        <span class="cov8" title="1">return storage</span>
}

// AddURL adds a new URL mapping to the storage.
// Thread-safe operation that stores the mapping with user association.
func (s *URLStorage) AddURL(shortURL, originalURL, userID string) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.URLs[shortURL] = URLInfo{OriginalURL: originalURL, UserID: userID}
        return nil
}</span>

// AddURLs adds multiple URL mappings in a single operation.
// More efficient than multiple AddURL calls for batch operations.
func (s *URLStorage) AddURLs(urls map[string]string, userID string) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        for shortURL, originalURL := range urls </span><span class="cov8" title="1">{
                s.URLs[shortURL] = URLInfo{OriginalURL: originalURL, UserID: userID}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetURL retrieves URL information by short URL.
// Returns original URL, existence flag, and deletion status.
func (s *URLStorage) GetURL(shortURL string) (string, bool, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        info, exists := s.URLs[shortURL]
        if !exists </span><span class="cov8" title="1">{
                return "", false, false
        }</span>
        <span class="cov8" title="1">return info.OriginalURL, true, info.IsDeleted</span>
}

// GetURLsByUser retrieves all URLs created by a specific user.
// Uses sync.Pool for efficient map allocation and reuse.
func (s *URLStorage) GetURLsByUser(userID string) (map[string]string, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        urls := s.mapPool.Get().(map[string]string)
        defer func() </span><span class="cov8" title="1">{
                for k := range urls </span><span class="cov0" title="0">{
                        delete(urls, k)
                }</span>
                <span class="cov8" title="1">s.mapPool.Put(urls)</span>
        }()

        <span class="cov8" title="1">result := make(map[string]string, len(urls))

        for short, info := range s.URLs </span><span class="cov8" title="1">{
                if info.UserID == userID </span><span class="cov8" title="1">{
                        result[short] = info.OriginalURL
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// GetAllURLs returns a copy of all stored URL mappings.
// Creates a new map to avoid exposing internal storage.
func (s *URLStorage) GetAllURLs() map[string]string <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        urlMap := make(map[string]string, len(s.URLs))
        for short, info := range s.URLs </span><span class="cov8" title="1">{
                urlMap[short] = info.OriginalURL
        }</span>
        <span class="cov8" title="1">return urlMap</span>
}

// IterateURLs calls the provided function for each URL mapping.
// Provides efficient iteration without copying all data.
func (s *URLStorage) IterateURLs(fn func(shortURL, originalURL string)) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        for short, info := range s.URLs </span><span class="cov8" title="1">{
                fn(short, info.OriginalURL)
        }</span>
}

// Count returns the total number of stored URL mappings.
// Thread-safe read operation.
func (s *URLStorage) Count() int <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.URLs)
}</span>

// GetShortURLByOriginalURL finds the short URL for a given original URL.
// Returns short URL and found flag by iterating through all mappings.
func (s *URLStorage) GetShortURLByOriginalURL(originalURL string) (string, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        for short, info := range s.URLs </span><span class="cov8" title="1">{
                if info.OriginalURL == originalURL </span><span class="cov8" title="1">{
                        return short, true
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

// DeleteURLs marks specified URLs as deleted for the given user.
// Only URLs owned by the user are marked for deletion.
func (s *URLStorage) DeleteURLs(shortURLs []string, userID string) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        for _, shortURL := range shortURLs </span><span class="cov8" title="1">{
                if info, exists := s.URLs[shortURL]; exists &amp;&amp; info.UserID == userID </span><span class="cov8" title="1">{
                        info.IsDeleted = true
                        s.URLs[shortURL] = info
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Ping checks storage availability (always returns nil for in-memory storage).
func (s *URLStorage) Ping() error <span class="cov8" title="1">{
        return nil
}</span>

// Close performs cleanup operations (no-op for in-memory storage).
func (s *URLStorage) Close() error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
